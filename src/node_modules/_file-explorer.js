var setval = require('setval')
var yo = require('yo-yo')
var csjs = require('csjs-inject')
var Treeview = require('ethereum-remix').ui.TreeView

var css = csjs`
  .treeview {
    display: block;
    margin-top: 7px;
    width: 20%;
  }
  .folder,
  .file {
    font-size: 14px;
  }
  .hasFocus {
    background-color: #F4F6FF;
  }
  .rename {
    background-color: white;
  }
  .remove,
  .save {
    align-self: center;
    margin-right: 3%;
  }
  .activeMode {
    display: flex;
    justify-content: space-between;
  }
`
module.exports = fileExplorer

function fileExplorer (container, files, editor) {

  container.className = css.treeview

  var sources = {
    'test/client/credit.sol': '',
    'src/voting.sol': '',
    'src/leasing.sol': '',
    'src/gmbh/contract.sol': false,
    'src/gmbh/test.sol': false,
    'src/gmbh/company.sol': false,
    'src/gmbh/node_modules/ballot.sol': false,
    'src/ug/finance.sol': false,
    'app/solidity/mode.sol': true,
    'app/ethereum/constitution.sol': true
  }
  Object.keys(sources).forEach(function (key) { files.set(key, sources[key]) })

  var deleteButton = yo`<span class=${css.remove} onclick=${deletePath}><i class="fa fa-trash" aria-hidden="true"></i></span>`

  // files.event.register('fileChanged', function (filepath) { })
  files.event.register('fileAdded', function (filepath) {
    console.log('fileAdded', filepath)
  })
  files.event.register('fileFocus', function (path) {
    if (filepath == path) return
    filepath = path
    var el = getElement(filepath)
    var tmp = el
    while ((tmp = tmp.parentElement.parentElement) && tmp.tagName === 'LI') {
      var caret = tmp.firstChild.firstChild
      if (caret.classList.contains('fa-caret-right')) caret.click() // expand
    }
    el.click() // focus element
  })
  files.event.register('fileRemoved', function (filepath) {
    console.log('fileRemoved', filepath)
  })
  files.event.register('fileRenamed', function (oldName, newName) {
    var el = getElement(oldName)
    if (el) {
      oldName = oldName.split('/')
      newName = newName.split('/')
      var index = oldName.reduce(function (idx, key, i) {
        return oldName[i] !== newName[i] ? i : idx
      }, undefined)
      var newKey  = newName[index]
      var oldPath = oldName.slice(0,index+1).join('/')
      el = getElement(oldPath)
      el.firstChild.lastChild.firstChild.innerText = newKey
    }
  })

  var filenames = files.list()
  var data = { }
  Object.keys(filenames).forEach(file => setval(data, file, true))
  var filepath = null
  var focusElement = null
  var textUnderEdit = null

  var tv = new Treeview({
    extractData: function (subtree, tree, key) {
      return {
        children: subtree instanceof Array ? subtree.map((item, index) => ({
          key: index, value: item
        })) : subtree instanceof Object ? Object.keys(subtree).map(key => ({
          key: key, value: subtree[key]
        })) : undefined
      }
    },
    formatSelf: function (key, data) {
      return yo`<label class=${data.children ? css.folder : css.file}
        onload=${function (el) { adaptEnvironment(el, focus, hover) }}
        onunload=${function (el) { unadaptEnvironment(el, focus, hover) }}
        onclick=${editModeOn}
        onkeydown=${editModeOff}
        onblur=${editModeOff}
      >${key}</label>`
    }
  })

  container.appendChild(tv.render(data))

  setTimeout(function () { // infere first active element from tab bar
    var activePath = document.querySelector('.file.active').firstChild.innerText
    var el = getElement(activePath)
    focus.call(el,{})
  },0)

  var api = { }

  return api
  /******************************************************************************
    HELPER FUNCTIONS (per instance)
  ******************************************************************************/
  function focus (event) {
    event.cancelBubble = true
    if (focusElement === this) return
    if (focusElement) focusElement.classList.toggle(css.hasFocus)
    focusElement = this
    focusElement.classList.toggle(css.hasFocus)
    var filepath = getPath(focusElement).file
    if (filepath) files.event.trigger('fileFocus', [filepath])
  }
  function hover (event) {
    if (event.type === 'mouseout') {
      var exitedTo = event.toElement || event.relatedTarget
      if (this.contains(exitedTo)) return
      return this.removeChild(deleteButton)
    }
    this.appendChild(deleteButton)
  }
  function getPath (el) { return getPathRoot(container, el) }
  function getElement (path) { return getElementRoot(container, path) }
  function deletePath (event) {
    event.cancelBubble = true
    var el = this.parentElement.parentElement
    var path = getPath(el)
    if (confirm(`
      Do you really want to delete "${path.file||path.folder}" ?
      ${path.folder ? '(and all contained files and folders)' : ''}
    `)) {
      path = path.file || path.folder
      el.parentElement.removeChild(el)
      removeSubtree(files, path)
    }
  }
  function editModeOn (event) {
    var classes = this.parentElement.parentElement.parentElement.className
    if (~classes.indexOf('hasFocus') && !this.getAttribute('contenteditable')) {
      textUnderEdit = this.innerText
      this.setAttribute('contenteditable', true)
      this.classList.add(css.rename)
      this.focus()
    }
  }
  function editModeOff (event) {
    if (event.type === 'blur' || event.which === 27 || event.which === 13) {
      if (event.which === 13) {
        event.preventDefault()
        save = true
      } else if (textUnderEdit !== this.innerText) var save = confirm(`
        Do you want to rename?
      `)
      if (save) {
        var newPath = getPath(this.parentElement.parentElement.parentElement)
        newPath = newPath.folder || newPath.file
        var oldPath = newPath.split('/')
        oldPath.pop()
        oldPath.push(textUnderEdit)
        oldPath = oldPath.join('/')
        var isReadOnly = updateAllFiles(oldPath, newPath)
        if (isReadOnly) {
          alert(`
            couldn't rename - path contains "readonly" items
          `)
          this.innerText = textUnderEdit
        } else textUnderEdit = this.innerText
      }
      else this.innerText = textUnderEdit
      this.removeAttribute('contenteditable')
      this.classList.remove(css.rename)
    }
  }
  function updateAllFiles (oldPath, newPath) {
    var allFiles = files.list()
    var allPaths = Object.keys(allFiles)
    for (var i=0, len=allPaths.length, isOK=true; i<len; i++) {
      if (files.isReadOnly(allPaths[i])) {
        isOK = false
        break
      }
    }
    if (isOK) return (allPaths.forEach(function (path) {
      if (~path.indexOf(oldPath)) {
        var newName = path.replace(oldPath, newPath)
        files.rename(path, newName)
      }
    }),false)
    return true
  }
}
/******************************************************************************
  HELPER FUNCTIONS
******************************************************************************/
function adaptEnvironment (el, focus, hover) {
  var node1 = el.parentElement.parentElement.parentElement
  var node2 = el.parentElement.parentElement
  // add focus
  node1.addEventListener('click', focus)
  // add hover
  node2.classList.add(css.activeMode)
  node2.addEventListener('mouseover', hover)
  node2.addEventListener('mouseout', hover)
}

function unadaptEnvironment (el, focus, hover) {
  var node1 = el.parentElement.parentElement.parentElement
  var node2 = el.parentElement.parentElement
  // remove focus
  node1.removeEventListener('click', focus)
  // remove hover
  node2.classList.remove(css.activeMode)
  node2.removeEventListener('mouseover', hover)
  node2.removeEventListener('mouseout', hover)
}

function removeSubtree (files, path) {
  var allPaths = Object.keys(files.list())
  var remove = allPaths.filter(function keep (p) { return ~p.indexOf(path) })
  remove.forEach(function (p) { files.remove(p) })
}

function getElementRoot (container, path) {
  path = path.split('/')
  var lis = container.children[0].children
  return getElementRecursive(path, lis)
}

function getElementRecursive (path, lis) {
  var current = path.shift()
  if (path.length) {
    lis = [].slice.call(lis)
      .map(toFolderEl)
      .filter(keepNonNull)
      .filter(function keep (el) { return el.innerText === current})[0]
    if (!lis) return
    lis = lis.parentElement.parentElement.parentElement.lastChild.children
    return getElementRecursive(path, lis)
  }
  return [].slice.call(lis).filter(function (el) {
    return (toFolderName(el.firstChild) || toFileName(el.firstChild)) === current
  })[0]
}

function getPathRoot (container, el) {
  var folder = toFolderName(el)
  var file = toFileName(el)
  var elPath = []
  // debugger
  while ((el = el.parentElement) && el !== container) elPath.unshift(el)
  elPath = elPath.filter(keepNotUL).map(toFolderName).concat([folder||file]).join('/')
  return folder ? { folder: elPath } : { file: elPath }
}

function keepNotUL (el) { return el.tagName !== 'UL' }

function keepNonNull (el) { return el !== null }

function toFolderEl (li) {
  return li.firstChild.querySelector(`.${css.folder}`)
}

function toFolderName (el) {
  return (el.querySelector(`.${css.folder}`)||{}).innerText
}
function toFileName (el) {
  return (el.querySelector(`.${css.file}`)||{}).innerText
}
